#!/usr/bin/python2
# -*- coding: utf-8 -*-

# Copyright (c) 2012 Martin Ueding <dev@martin-ueding.de>

import csv
import datetime
import itertools
import optparse
import os
import sys
import time

def avg(l):
    return sum(l) / len(l)


class Process(object):
    def __init__(self, pid, command, pstates=[]):
        self.pid = pid
        self.command = command
        self.pstates = pstates

    def add_pstate(self, pstate):
        self.pstates.append(pstate)
        
    def __repr__(self):
        return "Process(%s, %s, %s)" % (repr(self.pid), repr(self.command), repr(self.pstates))

class Computer(object):
    def __init__(self, cstates=[], tstates=[], processes={}):
        self.cstates = cstates
        self.tstates = tstates
        self.processes = processes

    def __repr__(self):
        return "Computer(%s, %s, %s)" % (repr(self.cstates), repr(self.tstates), repr(self.processes))
        
    def mintemp(self):
        return min([x.cpu for x in self.tstates]), min([x.mb for x in self.tstates])
        
    def maxtemp(self):
        return max([x.cpu for x in self.tstates]), max([x.mb for x in self.tstates])
        
    def avgtemp(self):
        return avg([x.cpu for x in self.tstates]), avg([x.mb for x in self.tstates])
        
    def cpustats(self):
        return {"cpu":  {"min": min([x.cpu for x in self.cstates]), "max": max([x.cpu for x in self.cstates]), "avg": avg([x.cpu for x in self.cstates])},
                "mem":  {"min": min([x.mem for x in self.cstates]), "max": max([x.mem for x in self.cstates]), "avg": avg([x.mem for x in self.cstates])},
                "swap": {"min": min([x.swap for x in self.cstates]), "max": max([x.swap for x in self.cstates]), "avg": avg([x.swap for x in self.cstates])}
          }

class PState(object):
    def __init__(self, time, cpu, mem, status):
        self.time = time
        self.cpu = cpu
        self.mem = mem
        self.status = status

    def __repr__(self):
        return "PState(%s, %s, %s, %s)" % (repr(self.time), repr(self.cpu), repr(self.mem), repr(self.status))
        
class CState(object):
    def __init__(self, time, cpu, mem, swap):
        self.time = time
        self.cpu = cpu
        self.mem = mem
        self.swap = swap

    def __repr__(self):
        return "CState(%s, %s, %s, %s)" % (repr(self.time), repr(self.cpu), repr(self.mem), repr(self.swap))

class TState(object):
    def __init__(self, time, cpu, mb):
        self.time = time
        self.cpu = cpu
        self.mb = mb

    def __repr__(self):
        return "TState(%s, %s, %s)" % (repr(self.time), repr(self.cpu), repr(self.mb))


def main():
    parser = optparse.OptionParser(usage="chaos_log folders...", description="Parses chaos log files and offeres summaries.")
    parser.add_option("--max", dest="max", action="store_true", default=False, help="Show min-max status.")
    parser.add_option("-v", dest="verbose", action="store_true", default=False, help="Show steps.")
    parser.add_option("--files", dest="files", action="store_true", default=False, help="Show each processed file.")
    parser.add_option("--computer", dest="computer", action="store_true", default=False, help="Report for whole computer.")
    parser.add_option("--process", dest="process", default=None, help="Report for only this process")
    parser.add_option("-o", dest="outfile", default="-", help="If given, write report into that file.")
    parser.add_option("--format", dest="format", default="csv", help="Choose CSV or Plain [default: %default]")
    parser.add_option("--dump", dest="dump", action="store_true", default=False, help="Dump whole data to outfile.")
    parser.add_option("--import", dest="importfile", default=None, help="Import from given dump.")

    
    # TODO Offer import and export of core data.

    global options
    (options, args) = parser.parse_args()
    del parser
    
    
    if options.outfile == "-":
        outfile = sys.stdout
    else:
        outfile = open(options.outfile, "w")

    global computer
    
    if options.importfile is None:
        computer = Computer()
    
    
        if len(args) < 1:
            print "I need some input."
            sys.exit(1)
    else:
        with open(options.importfile) as f:
            computer = eval(f.read())

    for infolder in args:
        os.path.walk(infolder, parsefolder, None)
    
    if options.max:
        cpustats = computer.cpustats()
        
        print "CPU Load   Min: %6.1f,   Max: %6.1f,   Avg: %6.1f " % (cpustats["cpu"]["min"], cpustats["cpu"]["max"], cpustats["cpu"]["avg"])
        print "Memory     Min: %6.1f M, Max: %6.1f M, Avg: %6.1f M" % (cpustats["mem"]["min"], cpustats["mem"]["max"], cpustats["mem"]["avg"])
        print "Swap       Min: %6.1f M, Max: %6.1f M, Avg: %6.1f M" % (cpustats["swap"]["min"], cpustats["swap"]["max"], cpustats["swap"]["avg"])
        print
      
        mintemp = computer.mintemp()
        maxtemp = computer.maxtemp()
        avgtemp = computer.avgtemp()
        print "CPU        Min: %3.1f °C,  Max: %3.1f °C,  Avg: %3.1f °C" % (mintemp[0], maxtemp[0], avgtemp[0])
        print "Mainboard  Min: %3.1f °C,  Max: %3.1f °C,  Avg: %3.1f °C" % (mintemp[1], maxtemp[1], avgtemp[1])
        
    if options.computer:        
        writer = csv.writer(outfile, quoting=csv.QUOTE_ALL)
        writer.writerow(["Timestamp", "Load Average", "Memory MB", "Swap MB", "Temp CPU °C", "Temp Mainboard °C"])
        for cpu, temp in zip(computer.cstates, computer.tstates):
            data = [time.mktime(cpu.time.timetuple()), cpu.cpu, cpu.mem, cpu.swap, temp.cpu, temp.mb]
            writer.writerow(data)
            
    if options.process is not None:
        selected = None
        for process in computer.processes:
            if process[1] == options.process:
                selected = computer.processes[process]
                
        if selected is None:
            print "There is no process %s." % options.process
            sys.exit(1)
            
        print selected
            
        writer = csv.writer(outfile, quoting=csv.QUOTE_ALL)
        mywrite(["Timestamp", "CPU %", "Memory %", "Status"], writer, outfile)
        for state in selected.pstates:
            data = [time.mktime(state.time.timetuple()), state.cpu, state.mem, state.status]
            mywrite(data, writer, outfile)
            
    if options.dump:
        outfile.write(repr(computer))
        outfile.write("\n")
        
    if options.outfile != "-":
        outfile.close()
        
def mywrite(datalist, writer, outfile):
    if options.format == "csv":
        writer.writerow(datalist)
    else:
        outfile.write(" ".join(map(str, datalist))+"\n")
        

def parsefolder(arg, dirname, names):
    names.sort()
    if options.verbose:
        print "Parsing", dirname
    for name in names:
        if not os.path.isfile(dirname+"/"+name):
            continue

        parsefile(dirname, name)
        
def gettime(dirname, name):
    timefolder = os.path.basename(dirname)
    datefolder = os.path.basename(os.path.dirname(dirname))
    
    time = datetime.datetime(int(datefolder[0:4]), int(datefolder[5:7]), int(datefolder[8:10]), int(timefolder[:2]), int(name[:2]))
     
    return time

def parsefile(dirname, name):
    if name.endswith("processes.log"):
        if options.files:
            print "Parsing", dirname+"/"+name
        parseprocesses(dirname, name, gettime(dirname, name))
    elif name.endswith("sensors.log"):   
        if options.files:
            print "Parsing", dirname+"/"+name
        parsetemp(dirname, name, gettime(dirname, name))

def parseprocesses(dirname, name, time):
    with open(dirname+"/"+name) as f:
        cpu = float(f.readline().split()[12][:-1])
        f.readline()
        f.readline()
        mem = float(f.readline().split()[3][:-1]) / 1024
        swap = float(f.readline().split()[3][:-1]) / 1024
        
        f.readline()
        f.readline()
        
        cstate = CState(time, cpu, mem, swap)
        
        computer.cstates.append(cstate)

        for line in f:
            data = line.split()

            if len(data) < 12:
                continue

            pid = int(data[0])
            command = data[11]

            state = PState(time, float(data[8]), float(data[9]), data[7])

            key = (pid, command)
            
            if key in computer.processes:
                current = computer.processes[key]
            else:
                current = Process(pid, command, [])
                computer.processes[(pid, command)] = current

            current.pstates.append(state)

def parsetemp(dirname, name, time):
    with open(dirname+"/"+name) as f:
      lines = f.read().split("\n")
      
      if len(lines) < 11:
        return
      
      cpu = float(lines[9].split()[2])
      mb = float(lines[10].split()[2])
      
      state = TState(time, cpu, mb)
      computer.tstates.append(state)



if __name__ == "__main__":
    main()
