#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) 2012 Martin Ueding <dev@martin-ueding.de>

"""
Script to parse snapshots of `top` and `sensors` from a server.
"""

__docformat__ = "javadoc en"

import csv
import datetime
import itertools
import optparse
import os
import sys
import time

from computer import *
from parser import *


def main():
    parser = optparse.OptionParser(usage="chaos_log folders...", description="Parses chaos log files and offeres summaries.")
    parser.add_option("--max", dest="max", action="store_true", default=False, help="Show min-max status.")
    parser.add_option("-v", dest="verbose", action="store_true", default=False, help="Show steps.")
    parser.add_option("--files", dest="files", action="store_true", default=False, help="Show each processed file.")
    parser.add_option("--computer", dest="computer", action="store_true", default=False, help="Report for whole computer.")
    parser.add_option("--process", dest="process", default=None, help="Report for only this process")
    parser.add_option("-o", dest="outfile", default="-", help="If given, write report into that file.")
    parser.add_option("--format", dest="format", default="csv", help="Choose CSV or Plain [default: %default]")
    parser.add_option("--dump", dest="dump", action="store_true", default=False, help="Dump whole data to outfile.")
    parser.add_option("--import", dest="importfile", default=None, help="Import from given dump.")

    # XXX This sucks as well.
    global options

    (options, args) = parser.parse_args()
    del parser
    
    # If an output file is given, use that instead of standard output.
    if options.outfile == "-":
        outfile = sys.stdout
    else:
        outfile = open(options.outfile, "w")

    # XXX This is not good!
    global computer
    
    # Create a new computer if no import is given.
    if options.importfile is None:
        computer = Computer()
    
        # If nothing is imported, there have to be some files to parse.
        if len(args) < 1:
            print "I need some input."
            sys.exit(1)
    
    # Import the dump.
    else:
        with open(options.importfile) as f:
            computer = eval(f.read())

    # Iterate through all folders that are given on the command line.
    for infolder in args:
        os.path.walk(infolder, parsefolder, None)
    
    # Maximum Report.
    if options.max:
        cpustats = computer.cpustats()
        
        print "CPU Load   Min: %6.1f,   Max: %6.1f,   Avg: %6.1f " % (cpustats["cpu"]["min"], cpustats["cpu"]["max"], cpustats["cpu"]["avg"])
        print "Memory     Min: %6.1f M, Max: %6.1f M, Avg: %6.1f M" % (cpustats["mem"]["min"], cpustats["mem"]["max"], cpustats["mem"]["avg"])
        print "Swap       Min: %6.1f M, Max: %6.1f M, Avg: %6.1f M" % (cpustats["swap"]["min"], cpustats["swap"]["max"], cpustats["swap"]["avg"])
        print
      
        mintemp = computer.mintemp()
        maxtemp = computer.maxtemp()
        avgtemp = computer.avgtemp()
        print "CPU        Min: %3.1f °C,  Max: %3.1f °C,  Avg: %3.1f °C" % (mintemp[0], maxtemp[0], avgtemp[0])
        print "Mainboard  Min: %3.1f °C,  Max: %3.1f °C,  Avg: %3.1f °C" % (mintemp[1], maxtemp[1], avgtemp[1])
        
    # Computer Overview Report.
    if options.computer:        
        writer = csv.writer(outfile, quoting=csv.QUOTE_ALL)
        writer.writerow(["Timestamp", "Load Average", "Memory MB", "Swap MB", "Temp CPU °C", "Temp Mainboard °C"])
        for cpu, temp in zip(computer.cstates, computer.tstates):
            data = [time.mktime(cpu.time.timetuple()), cpu.cpu, cpu.mem, cpu.swap, temp.cpu, temp.mb]
            writer.writerow(data)
            
    # Single Process Report.
    if options.process is not None:
        selected = None
        for process in computer.processes:
            if process[1] == options.process:
                selected = computer.processes[process]
                
        if selected is None:
            print "There is no process %s." % options.process
            sys.exit(1)
            
        writer = csv.writer(outfile, quoting=csv.QUOTE_ALL)
        mywrite(["Timestamp", "CPU %", "Memory %", "Status"], writer, outfile)
        for state in selected.pstates:
            data = [time.mktime(state.time.timetuple()), state.cpu, state.mem, state.status]
            mywrite(data, writer, outfile)
            
    # Complete Dump.
    if options.dump:
        outfile.write(repr(computer))
        outfile.write("\n")
        
    # If an outfile was used, close it.
    if options.outfile != "-":
        outfile.close()
        

def mywrite(datalist, writer, outfile):
    """
    Writes a list of data to the outfile either in CSV or plain text format.
    """
    if options.format == "csv":
        writer.writerow(datalist)
    else:
        outfile.write(" ".join(map(str, datalist))+"\n")
        

if __name__ == "__main__":
    main()
