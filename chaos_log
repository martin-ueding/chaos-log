#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) 2012 Martin Ueding <dev@martin-ueding.de>

"""
Script to parse snapshots of `top` and `sensors` from a server.
"""

__docformat__ = "javadoc en"

import csv
import datetime
import itertools
import optparse
import os
import sys
import time

from computer import *


def main():
    parser = optparse.OptionParser(usage="chaos_log folders...", description="Parses chaos log files and offeres summaries.")
    parser.add_option("--max", dest="max", action="store_true", default=False, help="Show min-max status.")
    parser.add_option("-v", dest="verbose", action="store_true", default=False, help="Show steps.")
    parser.add_option("--files", dest="files", action="store_true", default=False, help="Show each processed file.")
    parser.add_option("--computer", dest="computer", action="store_true", default=False, help="Report for whole computer.")
    parser.add_option("--process", dest="process", default=None, help="Report for only this process")
    parser.add_option("-o", dest="outfile", default="-", help="If given, write report into that file.")
    parser.add_option("--format", dest="format", default="csv", help="Choose CSV or Plain [default: %default]")
    parser.add_option("--dump", dest="dump", action="store_true", default=False, help="Dump whole data to outfile.")
    parser.add_option("--import", dest="importfile", default=None, help="Import from given dump.")

    global options
    (options, args) = parser.parse_args()
    del parser
    
    # If an output file is given, use that instead of standard output.
    if options.outfile == "-":
        outfile = sys.stdout
    else:
        outfile = open(options.outfile, "w")

    # Make computer global.
    # XXX This is not good!
    global computer
    
    # Create a new computer if no import is given.
    if options.importfile is None:
        computer = Computer()
    
        # If nothing is imported, there have to be some files to parse.
        if len(args) < 1:
            print "I need some input."
            sys.exit(1)
    
    # Import the dump.
    else:
        with open(options.importfile) as f:
            computer = eval(f.read())

    # Iterate through all folders that are given on the command line.
    for infolder in args:
        os.path.walk(infolder, parsefolder, None)
    
    # Maximum Report.
    if options.max:
        cpustats = computer.cpustats()
        
        print "CPU Load   Min: %6.1f,   Max: %6.1f,   Avg: %6.1f " % (cpustats["cpu"]["min"], cpustats["cpu"]["max"], cpustats["cpu"]["avg"])
        print "Memory     Min: %6.1f M, Max: %6.1f M, Avg: %6.1f M" % (cpustats["mem"]["min"], cpustats["mem"]["max"], cpustats["mem"]["avg"])
        print "Swap       Min: %6.1f M, Max: %6.1f M, Avg: %6.1f M" % (cpustats["swap"]["min"], cpustats["swap"]["max"], cpustats["swap"]["avg"])
        print
      
        mintemp = computer.mintemp()
        maxtemp = computer.maxtemp()
        avgtemp = computer.avgtemp()
        print "CPU        Min: %3.1f °C,  Max: %3.1f °C,  Avg: %3.1f °C" % (mintemp[0], maxtemp[0], avgtemp[0])
        print "Mainboard  Min: %3.1f °C,  Max: %3.1f °C,  Avg: %3.1f °C" % (mintemp[1], maxtemp[1], avgtemp[1])
        
    # Computer Overview Report.
    if options.computer:        
        writer = csv.writer(outfile, quoting=csv.QUOTE_ALL)
        writer.writerow(["Timestamp", "Load Average", "Memory MB", "Swap MB", "Temp CPU °C", "Temp Mainboard °C"])
        for cpu, temp in zip(computer.cstates, computer.tstates):
            data = [time.mktime(cpu.time.timetuple()), cpu.cpu, cpu.mem, cpu.swap, temp.cpu, temp.mb]
            writer.writerow(data)
            
    # Single Process Report.
    if options.process is not None:
        selected = None
        for process in computer.processes:
            if process[1] == options.process:
                selected = computer.processes[process]
                
        if selected is None:
            print "There is no process %s." % options.process
            sys.exit(1)
            
        writer = csv.writer(outfile, quoting=csv.QUOTE_ALL)
        mywrite(["Timestamp", "CPU %", "Memory %", "Status"], writer, outfile)
        for state in selected.pstates:
            data = [time.mktime(state.time.timetuple()), state.cpu, state.mem, state.status]
            mywrite(data, writer, outfile)
            
    # Complete Dump.
    if options.dump:
        outfile.write(repr(computer))
        outfile.write("\n")
        
    # If an outfile was used, close it.
    if options.outfile != "-":
        outfile.close()
        

def mywrite(datalist, writer, outfile):
    """
    Writes a list of data to the outfile either in CSV or plain text format.
    """
    if options.format == "csv":
        writer.writerow(datalist)
    else:
        outfile.write(" ".join(map(str, datalist))+"\n")
        

def parsefolder(arg, dirname, names):
    """
    Parses a folder. All files are passed to the parsefile function.
    """
    names.sort()
    if options.verbose:
        print "Parsing", dirname
    for name in names:
        if not os.path.isfile(dirname+"/"+name):
            continue

        parsefile(dirname, name)
        

def gettime(dirname, name):
    """
    Parses a time from the folder name.
    """
    timefolder = os.path.basename(dirname)
    datefolder = os.path.basename(os.path.dirname(dirname))
    
    time = datetime.datetime(int(datefolder[0:4]), int(datefolder[5:7]), int(datefolder[8:10]), int(timefolder[:2]), int(name[:2]))
     
    return time


def parsefile(dirname, name):
    """
    Determines which type of file is given and calls the apropriate parse method.
    """
    if name.endswith("processes.log"):
        if options.files:
            print "Parsing", dirname+"/"+name
        parseprocesses(dirname, name, gettime(dirname, name))
    elif name.endswith("sensors.log"):   
        if options.files:
            print "Parsing", dirname+"/"+name
        parsetemp(dirname, name, gettime(dirname, name))


def parseprocesses(dirname, name, time):
    """
    Parse a process file.
    """
    with open(dirname+"/"+name) as f:
        cpu = float(f.readline().split()[12][:-1])
        f.readline()
        f.readline()
        mem = float(f.readline().split()[3][:-1]) / 1024
        swap = float(f.readline().split()[3][:-1]) / 1024
        
        f.readline()
        f.readline()
        
        cstate = CState(time, cpu, mem, swap)
        
        computer.cstates.append(cstate)

        for line in f:
            data = line.split()

            if len(data) < 12:
                continue

            pid = int(data[0])
            command = data[11]

            state = PState(time, float(data[8]), float(data[9]), data[7])

            key = (pid, command)
            
            if key in computer.processes:
                current = computer.processes[key]
            else:
                current = Process(pid, command, [])
                computer.processes[(pid, command)] = current

            current.pstates.append(state)


def parsetemp(dirname, name, time):
    """
    Parse a temperature file.
    """
    with open(dirname+"/"+name) as f:
      lines = f.read().split("\n")
      
      if len(lines) < 11:
        return
      
      cpu = float(lines[9].split()[2])
      mb = float(lines[10].split()[2])
      
      state = TState(time, cpu, mb)
      computer.tstates.append(state)


if __name__ == "__main__":
    main()
