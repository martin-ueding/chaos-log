#!/usr/bin/python2
# -*- coding: utf-8 -*-

# Copyright (c) 2012 Martin Ueding <dev@martin-ueding.de>

import datetime
import itertools
import optparse
import os
import sys

def avg(l):
    return sum(l) / len(l)


class Process(object):
    def __init__(self, pid, command):
        self.pid = pid
        self.command = command
        self.pstates = []

    def add_pstate(self, pstate):
        self.pstates.append(pstate)
        
    def __repr__(self):
        return "Process(%s, %s, %s)" % (repr(self.pid), repr(self.command), repr(self.pstates))

class Computer(object):
    def __init__(self, cstates=[], tstates=[], processes={}):
        self.cstates = cstates
        self.tstates = tstates
        self.processes = processes

    def __repr__(self):
        return "Computer(%s, %s, %s)" % (repr(self.cstates), repr(self.tstates), repr(self.processes))
        
    def mintemp(self):
        return min([x.cpu for x in self.tstates]), min([x.mb for x in self.tstates])
        
    def maxtemp(self):
        return max([x.cpu for x in self.tstates]), max([x.mb for x in self.tstates])
        
    def avgtemp(self):
        return avg([x.cpu for x in self.tstates]), avg([x.mb for x in self.tstates])

class PState(object):
    def __init__(self, time, cpu, mem, status):
        self.time = time
        self.cpu = cpu
        self.mem = mem
        self.status = status

    def __repr__(self):
        return "PState(%s, %s, %s, %s)" % (repr(self.time), repr(self.cpu), repr(self.mem), repr(self.status))
        
class CState(object):
    def __init__(self, time, cpu, mem, swap):
        self.time = time
        self.cpu = cpu
        self.mem = mem
        self.swap = swap

    def __repr__(self):
        return "CState(%s, %s, %s, %s)" % (repr(self.time), repr(self.cpu), repr(self.mem), repr(self.swap))

class TState(object):
    def __init__(self, time, cpu, mb):
        self.time = time
        self.cpu = cpu
        self.mb = mb

    def __repr__(self):
        return "TState(%s, %s, %s)" % (repr(self.time), repr(self.cpu), repr(self.mb))


def main():
    parser = optparse.OptionParser()
    parser.add_option("--max", dest="max", action="store_true", default=False, help="Show min-max status")
    parser.add_option("-v", dest="verbose", action="store_true", default=False, help="Show steps")
    parser.add_option("--files", dest="files", action="store_true", default=False, help="Show each processed file")

    global options
    (options, args) = parser.parse_args()
    del parser
    

    global computer
    computer = Computer()
    
    if len(args) < 1:
        print "I need some input."
        sys.exit(1)

    for infolder in args:
        os.path.walk(infolder, parsefolder, None)
        
    #print repr(computer)
    
    if options.max:
	maxtemp = computer.mintemp()
	mintemp = computer.maxtemp()
	avgtemp = computer.avgtemp()
        print "CPU        Min: %3.1f, Max: %3.1f, Avg: %3.1f" % (mintemp[0], maxtemp[0], avgtemp[0])
        print "Mainboard  Min: %3.1f, Max: %3.1f, Avg: %3.1f" % (mintemp[1], maxtemp[1], avgtemp[1])

def parsefolder(arg, dirname, names):
    names.sort()
    if options.verbose:
        print "Parsing", dirname
    for name in names:
        if not os.path.isfile(dirname+"/"+name):
            continue

        parsefile(dirname, name)

def parsefile(dirname, name):
    timefolder = os.path.basename(dirname)
    datefolder = os.path.basename(os.path.dirname(dirname))
    
    time = datetime.datetime(
	int(datefolder[0:4]),
	int(datefolder[5:7]),
	int(datefolder[8:10]),
	int(timefolder[:2]),
	int(name[:2])
     )
        
    if name.endswith("processes.log"):
	if options.files:
	    print "Parsing", dirname+"/"+name
        parseprocesses(dirname, name, time)
    elif name.endswith("sensors.log"):   
	if options.files:
	    print "Parsing", dirname+"/"+name
        parsetemp(dirname, name, time)

def parseprocesses(dirname, name, time):
    with open(dirname+"/"+name) as f:
        f.readline()
        f.readline()
        cpu = 100.0 - float(f.readline().split()[4][:-4])
        mem = float(f.readline().split()[3][:-1])
        swap = float(f.readline().split()[3][:-1])
        
        f.readline()
        f.readline()
        
        cstate = CState(time, cpu, mem, swap)
        
        computer.cstates.append(cstate)

        for lineno, line in zip(itertools.count(), f):
                data = line.split()

                if len(data) < 12:
                    continue

                pid = int(data[0])
                command = data[11]

                state = PState(time, float(data[8]), float(data[9]), data[7])

                key = (pid, command)
                
                if key in computer.processes:
		    current = computer.processes[key]
		else:
                    current = Process(pid, command)
		    computer.processes[(pid, command)] = current

                current.pstates.append(state)

def parsetemp(dirname, name, time):
    with open(dirname+"/"+name) as f:
      lines = f.read().split("\n")
      
      if len(lines) < 11:
	return
      
      cpu = float(lines[9].split()[2])
      mb = float(lines[10].split()[2])
      
      state = TState(time, cpu, mb)
      computer.tstates.append(state)



if __name__ == "__main__":
    main()
